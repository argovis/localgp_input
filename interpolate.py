import numpy, argparse, pandas, scipy
from helpers import helpers

# argument setup 
def comma_separated_levels(s):
    return [float(item) for item in s.split(',')]

parser = argparse.ArgumentParser()
parser.add_argument("--input_file", type=str, help="parquet file generated by variable_creation.py")
parser.add_argument('--levels', type=comma_separated_levels, help="A comma-separated list of levels to interpolate to, e.g. --levels 1.0,2.5,3.0")
parser.add_argument("--pressure_buffer", type=float, nargs='?', const=100.0, default=100.0, help="pressure range to keep on either side of the pressure ROI")
parser.add_argument("--pressure_index_buffer", type=int, nargs='?', const=5, default=5, help="minimum number of elements to preserve in the pressure buffer margins")
args = parser.parse_args()

# load data, detect which variables are present
df = pandas.read_parquet(args.input_file, engine='pyarrow')
vars = [col for col in df.columns if isinstance(df.iloc[0][col], numpy.ndarray)]

def interpolate_to_levels(row, var, levels):
    try:
        # find indexes of ROI
        p_bracket = helpers.pad_bracket(row['pressure'], levels[0], levels[-1], args.pressure_buffer, args.pressure_index_buffer)

        # interpolate; don't extrapolate to levels outside of measurement range
        interp = scipy.interpolate.PchipInterpolator(row['pressure'][p_bracket[0]:p_bracket[1]+1], row[var][p_bracket[0]:p_bracket[1]+1], extrapolate=False)(levels)

        # if there wasn't a measured level within a certain radius of each level of interest, mask the interpolation at that level.
        interp = helpers.mask_far_interps(row['pressure'][p_bracket[0]:p_bracket[1]+1], levels, interp)
        
    except Exception as e:
        print(f'pchip interpolation failed at {var}, {row["juld"]}, {row["latitude"]}, {row["longitude"]}: {e}')
        interp = [numpy.nan]*len(levels)

    return interp

# interpolate everything to specified levels
for var in vars:
    if var == 'pressure':
        continue

    df[var] = df.apply(
        lambda row: interpolate_to_levels(row, var, args.levels),
        axis=1
    )

df['pressure'] = df.apply(
    lambda row: args.levels,
    axis=1
)

df.to_parquet(f"{args.input_file.split('.')[0]}_interpolated.parquet", engine='pyarrow')